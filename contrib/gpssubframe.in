#!@PYSHEBANG@
# -*- coding: utf-8 -*-
# @GENERATED@
# This file is Copyright 2010 by the GPSD project
# SPDX-License-Identifier: BSD-2-clause

# This code runs compatibly under Python 2 and 3.x for x >= 2.
# Preserve this property!
#

from __future__ import print_function

import argparse
import math
import socket
import sys
import time            # for time.time()

# pylint wants local modules last
try:
    import gps
except ImportError as e:
    sys.stderr.write(
        "%s: can't load Python gps libraries -- check PYTHONPATH.\n" %
        (sys.argv[0]))
    sys.stderr.write("%s\n" % e)
    sys.exit(1)

gps_version = '@VERSION@'
if gps.__version__ != gps_version:
    sys.stderr.write("%s: ERROR: need gps module version %s, got %s\n" %
                     (sys.argv[0], gps_version, gps.__version__))
    sys.exit(1)


def kepler(e, M0):
    '''Keplers iteration to solve his equation'''

    # https://en.wikipedia.org/wiki/Kepler%27s_equation
    Ek = M0             # initial guess
    for i in range(1, 20):
        temp = Ek
        Ek = M0 + e * math.sin(Ek)
        if 1e-10 > math.fabs(Ek - temp):
            break
    return Ek

# another kepler algorithm here:
# http://www.alpheratz.net/dynamics/twobody/KeplerIterations_summary.pdf


# FIXME!  Does not agree with satmap:
# real time sat positions: https://in-the-sky.org/satmap_worldmap.php
def SatPos(ephm, t):
    """Calculate GPS Satellite Position from Ephemeris/Almanac and t"""

    # compute Sat position from IS-GPS-200 table 20-IV
    # https://www.telesens.co/2017/07/17/calculating-position-from-raw-gps-data/#1b_Code_for_Calculating_Satellite_Position

    # Semi-major axis
    A = ephm['sqrtA'] ** 2      # meters

    # Computed mean motion
    n0 = math.sqrt(gps.WGS84GM / (A ** 3))           # rad/sec

    # Time from ephemeris reference epoch
    # t: GPS system time at time of transmission
    # FIXME: assume gps_tow is close enough to t
    tk = t - ephm['toe']
    if 302400 < tk:
        tk -= 604800
    elif -302400 > tk:
        tk += 604800

    # corrected mean motion
    n = n0 + ephm['deltan']   # rad/sec

    # mean anomaly, rads
    Mk = ephm['M0'] + (n * tk)

    # solve for eccentric anomaly
    Ek = kepler(ephm['e'], ephm['M0'])

    # true anomaly
    nuk = math.atan2(
       math.sqrt(1 - (ephm['e'] ** 2)) * math.sin(Ek) /
       (1 - ephm['e'] * math.cos(Ek)),
       (math.cos(Ek) - ephm['e']) / (1 - ephm['e'] * math.cos(Ek)))

    # alternate true anomaly
    # close enough?
    # nuk = math.atan2(math.sqrt(1 - (ephm['e'] ** 2)) * math.sin(Ek),
    #                  (math.cos(Ek) - ephm['e']))

    # Argument of Latitude
    Phik = nuk + ephm['omega']

    if 'Cus' in ephm:
        # 2nd harmonic corrections
        # Argument of Latitude Correction
        sin2Phik = math.sin(2 * Phik)
        cos2Phik = math.cos(2 * Phik)
        deltauk = (ephm['Cus'] * sin2Phik + ephm['Cuc'] * cos2Phik)
        # Radius Correction
        deltark = (ephm['Crs'] * sin2Phik + ephm['Crc'] * cos2Phik)
        # Inclination Correction
        deltaik = (ephm['Cis'] * sin2Phik + ephm['Cic'] * cos2Phik)
    else:
        deltauk = 0
        deltark = 0
        deltaik = 0

    # Corrected Argument of Latitude
    uk = Phik + deltauk

    # Corrected Radius
    rk = A * (1 - ephm['e'] * math.cos(Ek)) + deltark

    # Corrected Inclination Angle
    ik = ephm['i0'] + ephm['IDOT'] * tk + deltaik

    # Positions in orbital plane.
    xkprime = rk * math.cos(uk)
    ykprime = rk * math.sin(uk)

    # Corrected longitude of ascending node.
    Omegak = (ephm['Omega0'] + ((ephm['Omegad'] - gps.WGS84AV) * tk) -
              gps.WGS84AV * ephm['toe'])

    # Earth-fixed coordinates.
    ykprimecosik = ykprime * math.cos(ik)
    sinOmegak = math.sin(Omegak)
    cosOmegak = math.cos(Omegak)
    x = xkprime * cosOmegak - ykprimecosik * sinOmegak
    y = xkprime * sinOmegak + ykprimecosik * cosOmegak
    z = ykprime * math.sin(ik)

    if 1 < options.debug:
        print(ephm)
        print("gps_tow %d tk %s" % (gps_tow, tk))
        print("A %s n0 %s Mk %s" % (A, n0, Mk))
        print("Ek %s" % (Ek))
        print("nuk %.10g Ek %.10g Phik %.10g" % (nuk, Ek, Phik))
        print("deltauk %.10g deltark %.10g deltaik %.10g" %
              (deltauk, deltark, deltaik))
        print("uk %.10g rk %.10g ik %.10g" % (uk, rk, ik))
        print("xkprime %.10g ykprime %.10g Omegak %.10g" %
              (xkprime, ykprime, Omegak))

    # Finally, lat/lon/alt
    (lat, lon, altHAE) = gps.ecef2lla(x, y, z)
    print("x %.10g y %.10g z %.10g\n"
          "lat %.6f lon %.6f altHAE %.3f" %
          (x, y, z, lat, lon, altHAE))

    # ax and el to sat
    if 'lat' in tpv and 'lon' in tpv and 'altHAE' in tpv:
        (E, N, U) = gps.ecef2enu(x, y, z,
                                 tpv['lat'], tpv['lon'], tpv['altHAE'])
        print("E %.3f N %.3f U %.3f" % (E, N, U))
        (az, el, rng) = gps.enu2aer(E, N, U)
        print("az %.3f el %.3f rng %.3f" % (az, el, rng))


ephemeris1 = {}
ephemeris2 = {}
ephemeris3 = {}
# current almanac here: https://www.navcen.uscg.gov/?pageName=gpsAlmanacs
almanac = {}
tpv = None               # for current time and position


ephem1_fields = {
    1: ('ura', 'URA Index'),
    2: ('WN', 'Data Sequence Propagation Week Number'),
    3: ('L2P', 'L2 P data flag'),
    4: ('hlth', 'SV health'),
    5: ('Tgd', '(s) Group Delay Differential'),
    6: ('IODC', 'Issue of Data, Clock'),
    7: ('toc', '(s) Time of Clock'),
    8: ('L2', 'Code on L2'),
    9: ('af0', '(sc) SV Clock Bias Correction Coefficient'),
    10: ('af1', '(s) SV Clock Drift Correction Coefficient'),
    11: ('af2', '(s/s) Drift Rate Correction Coefficient'),
    }

ephem2_fields = {
    1: ('IODE', 'Issue of Data, Ephemeris'),
    2: ('M0', '(sc) Mean Anomaly at Reference Time'),
    3: ('deltan', '(sc/s) Mean Motion Difference from Computed Value'),
    4: ('e', 'Eccentricity '),
    5: ('sqrtA', '(sqrt(m))Square Root of the Semi-Major Axis'),
    6: ('FIT', 'Fit Interval Flag'),
    7: ('AODO', '(s) Age of Data Offset'),
    8: ('Crs', '(m) Sine Correction Amplitude Term to Orbit Radius'),
    9: ('Cus', '(rad) Cosine Correction Amplitude Term to Orbit Radius'),
    10: ('Cuc', '(rad) Sine Harmonic Correction Term to Arg of Lat'),
    11: ('toe', '(s) Reference Time Ephemeris')
    }

ephem3_fields = {
    1: ('IODE', 'Issue of Data, Ephemeris'),
    2: ('Crc', '(m) Cosine Harmonic Correction Amplitude Orbit Radius'),
    3: ('Cic',
        '(rad) Cosine Harmonic Correction Amplitude Angle of Inclination'),
    4: ('Cis',
        '(rad) Sine Harmonic Correction Amplitude Angle of Inclination'),
    5: ('Omega0',
        '(sc) Longitude of Ascending Node of Orbit Plane Week beginning'),
    6: ('i0', '(sc) Inclination Angle at Reference Time'),
    7: ('omega', '(sc) Argument of Perigee'),
    8: ('Omegad', '(sc/s) Rate of Right Ascension'),
    9: ('IDOT', '(sc/s) Rate of Inclination Angle'),
    }

almanac_fields = {
    # 1: ('ID' same as SV
    1: ('Health', 'SV health'),
    2: ('e', 'Eccentricity '),
    3: ('toa', '(s) Almanac Rference Time'),
    4: ('deltai', '(sc) Inclination offset from 0.3 semicircles (= 54 deg)'),
    5: ('Omegad', '(sc/s) Rate of Right Ascension'),
    6: ('sqrtA', '(m-2)Square Root of the Semi-Major Axis'),
    7: ('Omega0',
        '(sc) Longitude of Ascending Node of Orbit Plane Week beginning'),
    8: ('omega', '(sc) Argument of Perigee'),
    9: ('M0', '(sc) Mean Anomaly at Reference Time'),
    10: ('af0', '(s) SV Clock Bias Correction Coefficient'),
    11: ('af1', '(s/s) SV Clock Drift Correction Coefficient'),
    }


def _print_msg(sv, ephem, fields):
    """Print Subframe Data"""

    for index in sorted(fields.keys()):
        fld = fields[index]
        print("%10s %s" % (fld[0], ephem[fld[0]]))
        if options.desc:
            print("           %-48s " % (fld[1]))


description = 'Convert one gpsd JSON message class to csv format.'
usage = '%(prog)s [OPTIONS] [host[:port[:device]]]'
epilog = ('BSD terms apply: see the file COPYING in the distribution root'
          ' for details.')

parser = argparse.ArgumentParser(
             description=description,
             epilog=epilog,
             formatter_class=argparse.RawDescriptionHelpFormatter,
             usage=usage)
parser.add_argument(
    '--cvt-isotime',
    dest='cvtisotime',
    default=False,
    action="store_true",
    help='Convert ISO time to UNIX time [Default %(default)s)]'
)
parser.add_argument(
    '--desc',
    dest='desc',
    default=False,
    action="store_true",
    help='Print long descriptions [Default %(default)s)]'
)
parser.add_argument(
    '-D',
    '--debug',
    dest='debug',
    default=0,
    type=int,
    help='Set level of debug. Must be integer. [Default %(default)s)]'
)
parser.add_argument(
    '--device',
    dest='device',
    default='',
    help='The device to connect. [Default %(default)s)]'
)
parser.add_argument(
    '--host',
    dest='host',
    default='localhost',
    help='The host to connect. [Default %(default)s)]'
)
parser.add_argument(
    '-n',
    '--count',
    dest='count',
    default=0,
    type=int,
    help='Count of messages to parse. 0 to disable. [Default %(default)s)]'
)
parser.add_argument(
    '--port',
    dest='port',
    default=gps.GPSD_PORT,
    help='The port to connect. [Default %(default)s)]'
)
parser.add_argument(
    '--satpos',
    dest='satpos',
    default=False,
    action="store_true",
    help='Compute Satellite Positions [Default %(default)s)]'
)
parser.add_argument(
    '-V', '--version',
    action='version',
    version="%(prog)s: Version " + gps_version + "\n",
    help='Output version to stderr, then exit'
)
parser.add_argument(
    '-x',
    '--seconds',
    dest='seconds',
    default=16,
    type=int,
    help='Seconds of messages to parse. 0 to disable. [Default %(default)s)]'
)
parser.add_argument(
    'target',
    nargs='?',
    help='[host[:port[:device]]]'
)
options = parser.parse_args()

# the options host, port, device are set by the defaults
if options.target:
    # override host, port and device with target
    arg = options.target.split(':')
    len_arg = len(arg)
    if len_arg == 1:
        (options.host,) = arg
    elif len_arg == 2:
        (options.host, options.port) = arg
    elif len_arg == 3:
        (options.host, options.port, options.device) = arg
    else:
        parser.print_help()
        sys.exit(0)

try:
    session = gps.gps(host=options.host, port=options.port,
                      verbose=options.debug)
except socket.error:
    sys.stderr.write("gpscsv: Could not connect to gpsd daemon\n")
    sys.exit(1)

session.stream(gps.WATCH_ENABLE | gps.WATCH_SCALED, devpath=options.device)


count = 0
if 0 < options.seconds:
    end_seconds = time.time() + options.seconds
else:
    end_seconds = 0

try:
    while True:
        msg = session.next()
        if 'SUBFRAME' == msg['class']:
            if 1 == msg['frame']:
                ephemeris1[msg['tSV']] = msg['EPHEM1']
            elif 2 == msg['frame']:
                ephemeris2[msg['tSV']] = msg['EPHEM2']
            elif 3 == msg['frame']:
                ephemeris3[msg['tSV']] = msg['EPHEM3']
            elif 4 <= msg['frame'] <= 5:
                if 'ALMANAC' in msg:
                    almanac[msg['dataid']] = msg['ALMANAC']
                # else not Almanac page
            # else, bad packet...
        elif 'TPV' == msg['class']:
            tpv = msg

        if 0 < options.count:
            count += 1
            if count >= options.count:
                break

        if 0 < options.seconds:
            if time.time() > end_seconds:
                break

except KeyboardInterrupt:
    # caught control-C
    print()
    sys.exit(1)

all_sv = (ephemeris1.keys() + ephemeris2.keys() + ephemeris3.keys() +
          almanac.keys())
for sv in sorted(set(all_sv)):
    print("SV %u\n  Subframe 1, Clock Data" % sv)
    if sv in ephemeris1:
        _print_msg(sv, ephemeris1[sv], ephem1_fields)
    else:
        print("    Missing")
    print("  Subframe 2, Orbit Data")
    if sv in ephemeris2:
        _print_msg(sv, ephemeris2[sv], ephem2_fields)
    else:
        print("    Missing")
    print("  Subframe 3, Orbit Data")
    if sv in ephemeris3:
        _print_msg(sv, ephemeris3[sv], ephem3_fields)
    else:
        print("    Missing")
    print("  Almanac")
    if sv in almanac:
        _print_msg(sv, almanac[sv], almanac_fields)
    else:
        print("    Missing")

if 'time' in tpv:
    # convert to UNIX time
    unix_time = gps.isotime(tpv['time'])
    # GPS Epoch starts: Jan 1980 00:00:00 UTC, Unix time: 315964800
    gps_time = unix_time - 315964800
    if 'leapseconds' in tpv:
        gps_time += tpv['leapseconds']
    # 604,800 in a GPS week
    (gps_week, gps_tow) = divmod(gps_time, 604800)

    print("Unix time: %s, gps time: %s, week: %s tow: %s" %
          (unix_time, gps_time, int(gps_week), gps_tow))

    if not options.satpos:
        # done, do not continue to calc sat positions
        sys.exit(0)

    # below is WIP

    for sv in range(1, 33):
        if ((sv in ephemeris1 and
             sv in ephemeris2 and
             sv in ephemeris3)):

            print("\nSV %u EPhemeris position:" % sv)

            # mash into one dict
            # FIXME, check validity first
            ephm = ephemeris1[sv]
            ephm.update(ephemeris2[sv])
            ephm.update(ephemeris3[sv])

            # convert semi-circles to radians
            cvt = ('deltan', 'i0', 'IDOT', 'M0', 'omega', 'Omega0', 'Omegad')
            for i in cvt:
                ephm[i] *= math.pi

            SatPos(ephm, gps_tow)

        # FIXME: broken...
        if False and sv in almanac:
            print("\nSV %u Almanac position:" % sv)

            ephm = almanac[sv]
            ephm.update({'i0': ephm['deltai'] + 0.30,
                         'deltan': 0,
                         'IDOT': 0,
                         'toe': ephm['toa']})

            # convert semi-circles to radians
            cvt = ('deltan', 'i0', 'IDOT', 'M0', 'omega', 'Omega0', 'Omegad')
            for i in cvt:
                ephm[i] *= math.pi

            SatPos(ephm, gps_tow)
