#!@PYSHEBANG@
# @GENERATED@
# -*- coding: utf-8 -*-
# This file is Copyright 2010 by the GPSD project
# SPDX-License-Identifier: BSD-2-clause

# This code runs compatibly under Python 2 and 3.x for x >= 2.
# Preserve this property!
#

from __future__ import print_function

import argparse
import math
import socket
import sys
import time            # for time.time()

# pylint wants local modules last
try:
    import gps
except ImportError as e:
    sys.stderr.write(
        "%s: can't load Python gps libraries -- check PYTHONPATH.\n" %
        (sys.argv[0]))
    sys.stderr.write("%s\n" % e)
    sys.exit(1)

gps_version = '@VERSION@'
if gps.__version__ != gps_version:
    sys.stderr.write("%s: ERROR: need gps module version %s, got %s\n" %
                     (sys.argv[0], gps_version, gps.__version__))
    sys.exit(1)


def keppler(e, M0, n):
    '''Kepplers iteration to solve his equation'''

    # FIXME: iterate to a desired error, instead of fixed rounds?
    # https://en.wikipedia.org/wiki/Kepler%27s_equation
    Ek = M0             # initial guess
    for i in range(1, n):
        Ek = M0 + e * math.sin(Ek)
    return Ek

# another algorithm here:
# http://www.alpheratz.net/dynamics/twobody/KeplerIterations_summary.pdf


ephemeris1 = {}
ephemeris2 = {}
ephemeris3 = {}
almanac = {}
tpv = None               # for current time and position


ephem1_fields = {
    1: ('ura', 'URA Index'),
    2: ('WN', 'Data Sequence Propagation Week Number'),
    3: ('L2P', 'L2 P data flag'),
    4: ('hlth', 'SV health'),
    5: ('Tgd', '(s) Group Delay Differential'),
    6: ('IODC', 'Issue of Data, Clock'),
    7: ('toc', '(s) Time of Clock'),
    8: ('L2', 'Code on L2'),
    9: ('af0', '(sc) SV Clock Bias Correction Coefficient'),
    10: ('af1', '(s) SV Clock Drift Correction Coefficient'),
    11: ('af2', '(s/s) Drift Rate Correction Coefficient'),
    }

ephem2_fields = {
    1: ('IODE', 'Issue of Data, Ephemeris'),
    2: ('M0', '(sc) Mean Anomaly at Reference Time'),
    3: ('deltan', '(sc/s) Mean Motion Difference from Computed Value'),
    4: ('e', 'Eccentricity '),
    5: ('sqrtA', '(sqrt(m))Square Root of the Semi-Major Axis'),
    6: ('FIT', 'Fit Interval Flag'),
    7: ('AODO', '(s) Age of Data Offset'),
    8: ('Crs', '(m) Sine Correction Amplitude Term to Orbit Radius'),
    9: ('Cus', '(rad) Cosine Correction Amplitude Term to Orbit Radius'),
    10: ('Cuc', '(rad) Sine Harmonic Correction Term to Arg of Lat'),
    11: ('toe', '(s) Reference Time Ephemeris')
    }

ephem3_fields = {
    1: ('IODE', 'Issue of Data, Ephemeris'),
    2: ('Crc', '(m) Cosine Harmonic Correction Amplitude Orbit Radius'),
    3: ('Cic',
        '(rad) Cosine Harmonic Correction Amplitude Angle of Inclination'),
    4: ('Cis',
        '(rad) Sine Harmonic Correction Amplitude Angle of Inclination'),
    5: ('Omega0',
        '(sc) Longitude of Ascending Node of Orbit Plane Week beginning'),
    6: ('i0', '(sc) Inclination Angle at Reference Time'),
    7: ('omega', '(sc) Argument of Perigee'),
    8: ('Omegad', '(sc/s) Rate of Right Ascension'),
    9: ('IDOT', '(sc/s) Rate of Inclination Angle'),
    }

almanac_fields = {
    # 1: ('ID' same as SV
    1: ('Health', 'SV health'),
    2: ('e', 'Eccentricity '),
    3: ('toa', '(s) Almanac Rference Time'),
    4: ('deltai', '(sc) Inclination offset from 0.3 semicircles (= 54 deg)'),
    5: ('Omegad', '(sc/s) Rate of Right Ascension'),
    6: ('sqrtA', '(m-2)Square Root of the Semi-Major Axis'),
    7: ('Omega0',
        '(sc) Longitude of Ascending Node of Orbit Plane Week beginning'),
    8: ('omega', '(sc) Argument of Perigee'),
    9: ('M0', '(sc) Mean Anomaly at Reference Time'),
    10: ('af0', '(s) SV Clock Bias Correction Coefficient'),
    11: ('af1', '(s/s) SV Clock Drift Correction Coefficient'),
    }


def _print_msg(sv, ephem, fields):
    """Print Subframe Data"""

    for index in sorted(fields.keys()):
        fld = fields[index]
        print("%10s %s" % (fld[0], ephem[fld[0]]))
        if options.desc:
            print("           %-48s " % (fld[1]))


description = 'Convert one gpsd JSON message class to csv format.'
usage = '%(prog)s [OPTIONS] [host[:port[:device]]]'
epilog = ('BSD terms apply: see the file COPYING in the distribution root'
          ' for details.')

parser = argparse.ArgumentParser(
             description=description,
             epilog=epilog,
             formatter_class=argparse.RawDescriptionHelpFormatter,
             usage=usage)
parser.add_argument(
    '--cvt-isotime',
    dest='cvtisotime',
    default=False,
    action="store_true",
    help='Convert ISO time to UNIX time [Default %(default)s)]'
)
parser.add_argument(
    '--desc',
    dest='desc',
    default=False,
    action="store_true",
    help='Print long descriptions [Default %(default)s)]'
)
parser.add_argument(
    '-D',
    '--debug',
    dest='debug',
    default=0,
    type=int,
    help='Set level of debug. Must be integer. [Default %(default)s)]'
)
parser.add_argument(
    '--device',
    dest='device',
    default='',
    help='The device to connect. [Default %(default)s)]'
)
parser.add_argument(
    '--host',
    dest='host',
    default='localhost',
    help='The host to connect. [Default %(default)s)]'
)
parser.add_argument(
    '-n',
    '--count',
    dest='count',
    default=0,
    type=int,
    help='Count of messages to parse. 0 to disable. [Default %(default)s)]'
)
parser.add_argument(
    '--port',
    dest='port',
    default=gps.GPSD_PORT,
    help='The port to connect. [Default %(default)s)]'
)
parser.add_argument(
    '--satpos',
    dest='satpos',
    default=False,
    action="store_true",
    help='Compute Satellite Positions [Default %(default)s)]'
)
parser.add_argument(
    '-V', '--version',
    action='version',
    version="%(prog)s: Version " + gps_version + "\n",
    help='Output version to stderr, then exit'
)
parser.add_argument(
    '-x',
    '--seconds',
    dest='seconds',
    default=16,
    type=int,
    help='Seconds of messages to parse. 0 to disable. [Default %(default)s)]'
)
parser.add_argument(
    'target',
    nargs='?',
    help='[host[:port[:device]]]'
)
options = parser.parse_args()

# the options host, port, device are set by the defaults
if options.target:
    # override host, port and device with target
    arg = options.target.split(':')
    len_arg = len(arg)
    if len_arg == 1:
        (options.host,) = arg
    elif len_arg == 2:
        (options.host, options.port) = arg
    elif len_arg == 3:
        (options.host, options.port, options.device) = arg
    else:
        parser.print_help()
        sys.exit(0)

try:
    session = gps.gps(host=options.host, port=options.port,
                      verbose=options.debug)
except socket.error:
    sys.stderr.write("gpscsv: Could not connect to gpsd daemon\n")
    sys.exit(1)

session.stream(gps.WATCH_ENABLE | gps.WATCH_SCALED, devpath=options.device)


count = 0
if 0 < options.seconds:
    end_seconds = time.time() + options.seconds
else:
    end_seconds = 0

try:
    while True:
        msg = session.next()
        if 'SUBFRAME' == msg['class']:
            if 1 == msg['frame']:
                ephemeris1[msg['tSV']] = msg['EPHEM1']
            elif 2 == msg['frame']:
                ephemeris2[msg['tSV']] = msg['EPHEM2']
            elif 3 == msg['frame']:
                ephemeris3[msg['tSV']] = msg['EPHEM3']
            elif 4 <= msg['frame'] <= 5:
                if 'ALMANAC' in msg:
                    almanac[msg['dataid']] = msg['ALMANAC']
                # else not Almanac page
            # else, bad packet...
        elif 'TPV' == msg['class']:
            tpv = msg

        if 0 < options.count:
            count += 1
            if count >= options.count:
                break

        if 0 < options.seconds:
            if time.time() > end_seconds:
                break

except KeyboardInterrupt:
    # caught control-C
    print()
    sys.exit(1)

all_sv = (ephemeris1.keys() + ephemeris1.keys() + ephemeris1.keys() +
          almanac.keys())
for sv in sorted(set(all_sv)):
    print("SV %u\n  Subframe 1, Clock Data" % sv)
    if sv in ephemeris1:
        _print_msg(sv, ephemeris1[sv], ephem1_fields)
    else:
        print("    Missing")
    print("  Subframe 2, Orbit Data")
    if sv in ephemeris2:
        _print_msg(sv, ephemeris2[sv], ephem2_fields)
    else:
        print("    Missing")
    print("  Subframe 3, Orbit Data")
    if sv in ephemeris3:
        _print_msg(sv, ephemeris3[sv], ephem3_fields)
    else:
        print("    Missing")
    print("  Almanac")
    if sv in almanac:
        _print_msg(sv, almanac[sv], almanac_fields)
    else:
        print("    Missing")

if 'time' in tpv:
    # convert to UNIX time
    unix_time = gps.isotime(tpv['time'])
    # GPS Epoch starts: Jan 1980 00:00:00 UTC, Unix time: 315964800
    gps_time = unix_time - 315964800
    if 'leapseconds' in tpv:
        gps_time += tpv['leapseconds']
    # 604,800 in a GPS week
    (gps_week, gps_tow) = divmod(gps_time, 604800)

    print("Unix time: %s, gps time: %s, week: %s tow: %s" %
          (unix_time, gps_time, int(gps_week), gps_tow))

    if not options.satpos:
        # done, do not continue to calc sat positions
        sys.exit(0)

    # below is WIP

    # find one SV with all 3 ephemeris
    for sv in ephemeris1.keys():
        if ((sv not in ephemeris2 or
             sv not in ephemeris3)):
            continue
        # got one
        print("\nComputing SV %u position:" % sv)

        # compute Sat position from IS-GPS-200 table 20-IV
        # https://www.telesens.co/2017/07/17/calculating-position-from-raw-gps-data/#1b_Code_for_Calculating_Satellite_Position

        # WGS 84 value of the earth's gravitational constant for GPS user
        mu = 3.986005e14             # m/s
        # WGS 84 value of the earth's rotation rate
        omegade = 7.2921151467e-5    # rad/sec
        # Semi-major axis
        A = pow(ephemeris2[sv]['sqrtA'], 2)      # m

        # Computed mean motion
        comp_mm = math.sqrt(mu / pow(A, 3))           # rad/sec

        # Time from ephemeris reference epoch
        # t: GPS system time at time of transmission
        # FIXME: assume gps_tow is close enough to t
        tk = gps_tow - ephemeris2[sv]['toe']
        if 302400 > tk:
            tk -= 604800
        elif -302400 > tk:
            tk += 604800

        # corrected mean motion
        # deltan:  semi-circles -> rads
        corr_mm = comp_mm + (ephemeris2[sv]['deltan'] * math.pi)   # rad/sec

        # mean anomaly, rads
        # M0:  semi-circles -> rads
        M0 = ephemeris2[sv]['M0'] * math.pi
        Mk = (M0 * math.pi) + (corr_mm * tk)

        print("A %s comp_mm %s tk %s Mk %s" % (A, comp_mm, tk, Mk))

        # solve for eccentric anomaly
        # 5 seems enough
        Ek = keppler(ephemeris2[sv]['e'], M0, 5)
        print("Ek %s" % (Ek))

        # True anomaly:
        nuk = math.atan2(
           math.sqrt(1 - math.pow(ephemeris2[sv]['e'], 2) * math.sin(Ek)) /
           (1 - ephemeris2[sv]['e'] * math.cos(Ek)),
           (math.cos(Ek) - ephemeris2[sv]['e']) /
           (1 - ephemeris2[sv]['e'] * math.cos(Ek)))

        Ek = math.acos((ephemeris2[sv]['e'] + math.cos(nuk)) /
                       (1 + ephemeris2[sv]['e'] * math.cos(nuk)))

        # Argument of Latitude
        Phik = nuk + ephemeris2[sv]['e']
        print("nuk %.10g Ek %.10g Phik %.10g" % (nuk, Ek, Phik))

        # 2nd harmonic corrections
        # Argument of Latitude Correction
        deltauk = (ephemeris2[sv]['Cus'] * math.sin(2 * Phik) +
                   ephemeris2[sv]['Cuc'] * math.cos(2 * Phik))
        # Radius Correction
        deltark = (ephemeris2[sv]['Crs'] * math.sin(2 * Phik) +
                   ephemeris3[sv]['Crc'] * math.cos(2 * Phik))
        # Inclination Correction
        deltaik = (ephemeris3[sv]['Cis'] * math.sin(2 * Phik) +
                   ephemeris3[sv]['Cic'] * math.cos(2 * Phik))
        print("deltauk %.10g deltark %.10g deltaik %.10g" %
              (deltauk, deltark, deltaik))

        # Corrected Argument of Latitude
        uk = Phik + deltauk

        # Corrected Radius
        rk = A * (1 - ephemeris2[sv]['e'] * math.cos(Ek)) + deltark

        # Corrected Inclination Angle
        IDOT = ephemeris3[sv]['IDOT'] * math.pi
        ik = ephemeris3[sv]['i0'] + IDOT * tk + deltaik
        print("uk %.10g rk %.10g ik %.10g" % (uk, rk, ik))

        # Positions in orbital plane.
        xkprime = rk * math.cos(uk)
        ykprime = rk * math.sin(uk)

        # Corrected longitude of ascending node.
        Omega0 = ephemeris3[sv]['Omega0'] * math.pi
        Omegad = ephemeris3[sv]['Omegad'] * math.pi
        omega = (Omega0 + ((Omegad - omegade) * tk) -
                 omegade * ephemeris2[sv]['toe']
                 )
        print("xkprime %.10g ykprime %.10g omega %.10g" %
              (xkprime, ykprime, omega))

        # Finally! Earth-fixed coordinates.
        x = (xkprime * math.cos(omega) - ykprime * math.cos(ik) *
             math.sin(omega))
        y = (xkprime * math.sin(omega) + ykprime * math.cos(ik) *
             math.cos(omega))
        z = ykprime * math.sin(ik)
        print("x %.10g y %.10g z %.10g" % (x, y, z))

        (lat, lon, altHAE) = gps.ecef2lla(x, y, z)
        print("lat %.6f lon %.6f altHAE %.3f" % (lat, lon, altHAE))
